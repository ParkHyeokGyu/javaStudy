/*
 	객체지향의 3대 특성 => 권장사항
 	
 	class Window extends JFrame => 상속
 	=> 변경 사항이 있는 경우
 	class Window{
 		JFrame f=new JFrame(); => 포함
 	}
 	=> 변경사항이 없을 경우
 	
 	웹/스프링 => 상속은 거의 사용하지 않고 포함을 사용한다
 	
 	1. 캡슐화 : 데이터 보호
 		멤버변수	private(은닉화) => 기능 설정을 통하여 접근
 								 -------
 								 멤버변수의 기능 : 저장/읽기
 								  			  -------
 								  			  getter/setter
 				데이터를 감추고 메소드를 톨해서 접근하는 방식
 				
 	2. 상속/포함	기존의 클래스를 재사용
 		상속
 		1) 목적
 			재사용(신뢰성이 뛰어나다,개발속도가 빠르다)
 			유지보수를 쉽게 만든다
 			중복을 최대한 제거한다
 			통일성있는 코딩
 			단점 : 실행속도가 느리다
 			장점 : 적은 양의 코드로 새로운 클래스를 만들 수 있다
	 			class JFrame{
	 				-----
	 				-----
	 				...
	 			}
	 			
	 			class A extends JFrame
	 			
	 		코드를 공통적으로 관리하기때문에 여러 코드를 추가,변경이 용이
	 							           --------
	 							           오버로딩/오버라이딩
	 	*** 자바는 오버라이딩 프로그램이다
	 		프레임워크 => 변경이 쉽게하도록 소스를 제공 
				스프링(전자정부프레임워크)
 		
 		2) 작성방법
 			확장한다(extends) => 기존의 클래스를 확장해서 새로운 클래스 제작
 			class Parent
 			class Child extends Parent
 			단점 : 단일 상속만 가능하다
 		
 		3) 상속의 특징
 			생성자,초기화 블록을 상속이 되지 않는다
 			상속받은 클래스의 객체를 생성할때,상속을 내린 클래스가 먼저 메모리에 할당된다
 			class A{
 				int a,b;
 				String s;
 				public A(){} => 디폴트 생성자
 			}
 			class B entends A{
 				int c,d;
 				public B(){
 					super(); => 상속을 내린 클래스의 생성자 호출
 				}
 			}
 			
 			B b=new B();
 			
 			Stack => 메모리에서 처리(할당,해제)
 			b------
 			
 			-------		Heap => 실제 데이터 저장(프로그래머 관리)
 						-----------------------
 							super----------
 								a------
 								
 								b------
 								
 								s------
 								
 								-------
 							---------------
 							
 							this-----------
 								c------
 								
 								d------
 								
 								-------
 							---------------
 						
 						-----------------------
 		
 		모든 클래스의 상위 클래스(최상위 클래스) => Object
 		private는 상속은 되지만 접근이 불가능하다
 		protected는 상속을 받은 클래스에서 패키지가 동일하다면 접근이 가능하다
 		
 		상속 => 상위 클래스 => super
 			   자신 클래스 => this
 		
 		상속을 내리는 클래스는 상속받은 클래스에 접근이 불가능하다
 		상속받은 클래스는 자신은 물론 내리늘 클래스까지 접근이 가능하다
 		
 	3. 다형성
 		변경 => 오버라이딩
 		추가 => 오버로딩
 		
 		[접근지정어] 리턴형 메소드명(매개변수){}
 		
 				오버라이딩				오버로딩
 		---------------------------------------------
 		상태		상속					같은 클래스 안에서
 				=> 상속이 없어도 가능
 				=> 익명의 클래스
 		메소드명	동일					동일
 		매개변수	동일					갯수나 데이터형이 다르다
 		리턴형	동일					관계없다
 		접근지정어	축소(X),확대(O)		관계없다
 		---------------------------------------------
 		private < default < protected < public
 		예)
 			void aaa()
 			=> protected void aaa()
 			   public void aaa()
 			
 			메소드는 다른 클래스와 연결해서 사용함에 있어 대부분 public을 사용한다
 		
 		Modify : 기존의 기능 변경(오버라이딩), New : 새로운 기능 추가(오버로딩)
 		객체지향프로그램의 객체란 : 현실세계를 특성화 => 추상화 => 단순화
 		
 		상속의 예외 조건		static : 공통적으로 사용
 						private : 상속은 되지만 접근은 할 수 없다
 						생성자/초기화 블록
 		
 		주의점
			접근지정어
			클래스	[접근지정어] class 클래스명		public
			메소드	[접근지정어] 리턴형 메소드명)매개변수)	public
			멤버변수	[접근지정어] 데이터형 변수명		private,protected
			생성자	[접근지정어] 클래스명()			public
			
			지역변수,매개변수 => 접근지정어를 사용할 수 없다
							static 사용 할 수 없다
							final만이 사용 가능 => 상수
	
			메소드	
				멤버		static,멤버변수를 사용할 수 있다
				static	static만 사용할 수 있다
						만약 멤버변수나 멤버메소드를 사용하게될 경우 객체 생성 후에 사용할 수 있다
						
						class A{
							private int a;
							static int b;
							public void aaa(){
								a,b,bbb()
							}
							public static void bbb(){
								b
								a,aaa() => 객체 생성 후 사용 가능
								A a=new A();
								a.a,a.aaa()
							}
						}
			초기화 블록
				인스턴스
				{
					static,멤버변수를 초기화
				}
				static
				static
				{
					static변수만 초기화
				}
			
			변수에 대한 초기화
				명시적인 초기화 private int a=10;
				
				초기화 블록 : static 변수 초기화
				=> static은 생성자를 호출할 필요가 없다
				생성자 : 인스턴스 변수 초기화
				=> 인스턴스 변수는 new를 이용한 메모리할당이 이루어져야 메모리에 올라간다
				=> 시작과 동시에 처리
				   윈도우 : 화면설계
				   웹 : 자동로그인
				   일반 : 데이터베이스 연결,서버 연결
				   
				클래스 영역은 선언만 가능하다 => 구현 불가
				구현 => 연산처리,체어문,파일읽기,오라클 데이터
 				
 */
package com.sist.main;
class A{
	int a;

	public A() {
		super(); // Object
	}
}
class B extends A{
	int c;

	public B() {
		super();
	}
}
public class MainClass {
	public static void main(String[] args) {
		
	}
}
